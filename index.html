<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>SkateKUN parkour!! ~CitySide edition~</title>
    <style>
        body { margin: 0; overflow: hidden; background: #1a1a2e; font-family: 'Segoe UI', sans-serif; }
        canvas { display: block; background: linear-gradient(#0f0c29, #302b63, #24243e); }
        #ui { position: absolute; top: 20px; left: 20px; font-size: 28px; font-weight: bold; color: #fff; text-shadow: 2px 2px 0px #000; }
        #msg { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center; display: none; color: white; background: rgba(0,0,0,0.8); padding: 30px; border-radius: 15px; border: 2px solid #e91e63; }
        button { padding: 10px 20px; font-size: 18px; cursor: pointer; border-radius: 5px; border: none; background: #e91e63; color: white; margin-top: 15px; font-weight: bold; }
    </style>
</head>
<body>
    <div id="ui">Score: 0</div>
    <div id="msg">
        <h1 id="status">WIPEOUT!</h1>
        <p>スケートボードがっしゃ～ん！！</p>
        <button onclick="init()">RETRY</button>
    </div>
    <canvas id="gameCanvas"></canvas>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreElement = document.getElementById('ui');
        const msgElement = document.getElementById('msg');

        let gameState = 'playing';
        let score = 0;
        let speed = 6;
        const gravity = 0.7;
        const jumpPower = -14;

        const player = {
            x: 150,
            y: 0,
            width: 50,
            height: 10,
            dy: 0,
            jumpCount: 0,
            angle: 0,
            onGround: false
        };

        let platforms = [];
        let buildings = [];

        function init() {
            score = 0;
            speed = 6;
            player.y = 200;
            player.dy = 0;
            player.jumpCount = 0;
            player.angle = 0;
            platforms = [
                { x: 0, y: 500, w: 800 },
                { x: 950, y: 450, w: 500 }
            ];
            buildings = [];
            for (let i = 0; i < 10; i++) {
                addBuilding(Math.random() * window.innerWidth * 2);
            }
            gameState = 'playing';
            msgElement.style.display = 'none';
        }

        function addBuilding(x) {
            buildings.push({
                x: x,
                w: 60 + Math.random() * 100,
                h: 200 + Math.random() * 400,
                color: `hsl(${220 + Math.random() * 40}, 30%, ${15 + Math.random() * 15}%)`
            });
        }

        function update() {
            if (gameState !== 'playing') return;

            player.dy += gravity;
            player.y += player.dy;
            speed += 0.001;
            score += speed * 0.1;
            scoreElement.innerText = `Score: ${Math.floor(score)}`;

            // ジャンプ判定のロジック
            if (player.onGround) {
                player.angle = 0;
            } else {
                player.angle = Math.max(-0.4, Math.min(0.4, player.dy * 0.04));
                // 落下開始時に1段目消費とみなす
                if (player.dy > 0 && player.jumpCount === 0) {
                    player.jumpCount = 1;
                }
            }

            let landed = false;
            platforms.forEach(p => {
                p.x -= speed;

                // 衝突判定
                const pTop = p.y;
                const pBottom = canvas.height;
                const pLeft = p.x;
                const pRight = p.x + p.w;

                // プレイヤーの四端
                const plLeft = player.x;
                const plRight = player.x + player.width;
                const plTop = player.y;
                const plBottom = player.y + player.height;

                // 1. 上面着地判定
                if (plRight > pLeft && plLeft < pRight && 
                    plBottom > pTop && plBottom < pTop + player.dy + 10 && player.dy >= 0) {
                    player.y = pTop - player.height;
                    player.dy = 0;
                    player.jumpCount = 0;
                    landed = true;
                } 
                // 2. 側面衝突判定 (床の左端にぶつかったか)
                else if (plRight > pLeft && plLeft < pLeft + 20 && plBottom > pTop + 5) {
                    gameOver();
                }
            });
            player.onGround = landed;

            // 足場の生成
            let lastP = platforms[platforms.length - 1];
            if (lastP.x + lastP.w < canvas.width + 400) {
                platforms.push({
                    x: lastP.x + lastP.w + 120 + Math.random() * 200,
                    y: 300 + Math.random() * 250,
                    w: 300 + Math.random() * 400
                });
            }
            if (platforms[0].x + platforms[0].w < -100) platforms.shift();

            // ビルの移動と生成
            buildings.forEach(b => b.x -= speed * 0.3);
            if (buildings[0].x + buildings[0].w < -100) {
                buildings.shift();
                addBuilding(canvas.width + 100);
            }

            if (player.y > canvas.height) gameOver();
        }

        function gameOver() {
            gameState = 'over';
            msgElement.style.display = 'block';
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // 1. ビル（背景 - 必ず地面から）
            buildings.forEach(b => {
                ctx.fillStyle = b.color;
                ctx.fillRect(b.x, canvas.height - b.h, b.w, b.h);
                // 窓
                ctx.fillStyle = 'rgba(255, 255, 150, 0.2)';
                for(let iy = 0; iy < b.h; iy += 40) {
                    for(let ix = 10; ix < b.w - 10; ix += 30) {
                        ctx.fillRect(b.x + ix, canvas.height - b.h + iy + 10, 15, 15);
                    }
                }
            });

            // 2. 道
            platforms.forEach(p => {
                ctx.fillStyle = '#222'; // 側面（厚み）
                ctx.fillRect(p.x, p.y, p.w, canvas.height - p.y);
                ctx.fillStyle = '#444'; // 表面
                ctx.fillRect(p.x, p.y, p.w, 15);
                ctx.fillStyle = '#fff'; // 白線
                ctx.fillRect(p.x + 20, p.y + 7, p.w - 40, 2);
            });

            // 3. プレイヤー
            ctx.save();
            ctx.translate(player.x + player.width/2, player.y + player.height/2);
            ctx.rotate(player.angle);
            ctx.fillStyle = '#ff0066';
            ctx.beginPath();
            ctx.roundRect(-player.width/2, -player.height/2, player.width, 8, 4);
            ctx.fill();
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.arc(-18, 8, 5, 0, Math.PI*2);
            ctx.arc(18, 8, 5, 0, Math.PI*2);
            ctx.fill();
            ctx.restore();
        }

        function loop() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            update();
            draw();
            requestAnimationFrame(loop);
        }

        function handleJump() {
            if (gameState === 'playing') {
                if (player.jumpCount < 2) {
                    player.dy = jumpPower;
                    player.jumpCount++;
                }
            } else if (gameState === 'over') {
                init();
            }
        }

        window.addEventListener('keydown', (e) => { if(e.code === 'Space') handleJump(); });
        window.addEventListener('mousedown', (e) => { if(e.button === 0) handleJump(); });
        window.addEventListener('touchstart', (e) => { e.preventDefault(); handleJump(); }, {passive: false});

        init();
        loop();
    </script>
</body>

</html>
